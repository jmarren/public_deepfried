// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: pins.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteAllUserPins = `-- name: DeleteAllUserPins :exec


DELETE FROM pins
WHERE pins.user_id = $1
`

// WITH audio_ids AS (
//
//	SELECT file_id
//	FROM pins
//	WHERE pins.user_id = $1
//
// )
// SELECT
//
//	id,
//	title,
//	artwork_src,
//	audio_src
//
// FROM audio_files
// INNER JOIN audio_ids ON audio_ids.file_id = audio_files.id
// LIMIT 4;
func (q *Queries) DeleteAllUserPins(ctx context.Context, userID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteAllUserPins, userID)
	return err
}

const editUserPins = `-- name: EditUserPins :exec
INSERT INTO pins (user_id, file_id) 
SELECT 
        audio_files.user_id,
        audio_files.id
FROM 
        audio_files
WHERE audio_files.title = $2
    AND audio_files.user_id = $1
`

type EditUserPinsParams struct {
	UserID pgtype.UUID
	Title  string
}

func (q *Queries) EditUserPins(ctx context.Context, arg EditUserPinsParams) error {
	_, err := q.db.Exec(ctx, editUserPins, arg.UserID, arg.Title)
	return err
}

const getUserPins = `-- name: GetUserPins :many

WITH audio_ids AS (
    SELECT file_id
    FROM pins
    WHERE pins.user_id = $1
)
SELECT 
        playables.id, playables.user_id, playables.audio_src, playables.username, playables.title, playables.bpm, playables.playback_seconds, playables.created, playables.artwork_src,
        audio_file_tag_arrays.tag_array
FROM playables
JOIN audio_file_tag_arrays
        ON playables.id = audio_file_tag_arrays.id
JOIN audio_ids
        ON playables.id = audio_ids.file_id
LIMIT 4
`

type GetUserPinsRow struct {
	Playable Playable
	TagArray []string
}

// noqa
func (q *Queries) GetUserPins(ctx context.Context, userID pgtype.UUID) ([]GetUserPinsRow, error) {
	rows, err := q.db.Query(ctx, getUserPins, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserPinsRow
	for rows.Next() {
		var i GetUserPinsRow
		if err := rows.Scan(
			&i.Playable.ID,
			&i.Playable.UserID,
			&i.Playable.AudioSrc,
			&i.Playable.Username,
			&i.Playable.Title,
			&i.Playable.Bpm,
			&i.Playable.PlaybackSeconds,
			&i.Playable.Created,
			&i.Playable.ArtworkSrc,
			&i.TagArray,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertTestPin = `-- name: InsertTestPin :exec
INSERT INTO pins (user_id, file_id)
VALUES ($1, $2)
ON CONFLICT DO NOTHING
`

type InsertTestPinParams struct {
	UserID pgtype.UUID
	FileID pgtype.UUID
}

func (q *Queries) InsertTestPin(ctx context.Context, arg InsertTestPinParams) error {
	_, err := q.db.Exec(ctx, insertTestPin, arg.UserID, arg.FileID)
	return err
}
