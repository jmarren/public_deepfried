// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: tags.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addAudioFileTag = `-- name: AddAudioFileTag :exec
INSERT INTO audio_file_tags (tag_id, audio_file_id)
VALUES ($1, $2)
`

type AddAudioFileTagParams struct {
	TagID       int32
	AudioFileID pgtype.UUID
}

func (q *Queries) AddAudioFileTag(ctx context.Context, arg AddAudioFileTagParams) error {
	_, err := q.db.Exec(ctx, addAudioFileTag, arg.TagID, arg.AudioFileID)
	return err
}

const getAudioFileTags = `-- name: GetAudioFileTags :many

SELECT tags.tag_name
FROM tags
JOIN audio_file_tags 
ON audio_file_tags.tag_id = tags.id
JOIN audio_files
ON audio_files.id = audio_file_tags.audio_file_id
WHERE audio_file_id = $1
`

// get all audio files and their tags: ******
// SELECT tags.tag_name,audio_files.title
// FROM tags
// JOIN audio_file_tags
// ON audio_file_tags.tag_id = tags.id
// JOIN audio_files
// ON audio_files.id = audio_file_tags.audio_file_id;
func (q *Queries) GetAudioFileTags(ctx context.Context, audioFileID pgtype.UUID) ([]string, error) {
	rows, err := q.db.Query(ctx, getAudioFileTags, audioFileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var tag_name string
		if err := rows.Scan(&tag_name); err != nil {
			return nil, err
		}
		items = append(items, tag_name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAudioFileTagsWithTitleAndUsername = `-- name: GetAudioFileTagsWithTitleAndUsername :many
SELECT tags.tag_name
FROM tags
JOIN audio_file_tags
    ON audio_file_tags.tag_id = tags.id
JOIN audio_files
    ON audio_files.id = audio_file_tags.audio_file_id
JOIN users  
    ON users.id = audio_files.user_id
WHERE audio_files.title = $1
    AND users.username = $2
`

type GetAudioFileTagsWithTitleAndUsernameParams struct {
	Title    string
	Username string
}

func (q *Queries) GetAudioFileTagsWithTitleAndUsername(ctx context.Context, arg GetAudioFileTagsWithTitleAndUsernameParams) ([]string, error) {
	rows, err := q.db.Query(ctx, getAudioFileTagsWithTitleAndUsername, arg.Title, arg.Username)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var tag_name string
		if err := rows.Scan(&tag_name); err != nil {
			return nil, err
		}
		items = append(items, tag_name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagCount = `-- name: GetTagCount :one
SELECT 
    COUNT(*)
FROM tags
WHERE tag_name = $1
`

func (q *Queries) GetTagCount(ctx context.Context, tagName string) (int64, error) {
	row := q.db.QueryRow(ctx, getTagCount, tagName)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTagId = `-- name: GetTagId :one
SELECT tags.id
FROM tags
WHERE tag_name = $1
`

func (q *Queries) GetTagId(ctx context.Context, tagName string) (int32, error) {
	row := q.db.QueryRow(ctx, getTagId, tagName)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getTagsOrderedByCount = `-- name: GetTagsOrderedByCount :many
SELECT tags.tag_name 
FROM tags
JOIN audio_file_tags 
ON audio_file_tags.tag_id = tags.id
JOIN audio_files
ON audio_files.id = audio_file_tags.audio_file_id
GROUP BY tags.tag_name
ORDER BY COUNT(*) DESC
LIMIT 30
`

func (q *Queries) GetTagsOrderedByCount(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, getTagsOrderedByCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var tag_name string
		if err := rows.Scan(&tag_name); err != nil {
			return nil, err
		}
		items = append(items, tag_name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertTag = `-- name: InsertTag :one
INSERT INTO tags (tag_name)
VALUES ($1)
ON CONFLICT DO NOTHING
RETURNING id
`

func (q *Queries) InsertTag(ctx context.Context, tagName string) (int32, error) {
	row := q.db.QueryRow(ctx, insertTag, tagName)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const testAddAudioFileTag = `-- name: TestAddAudioFileTag :exec

INSERT INTO audio_file_tags (tag_id, audio_file_id)
VALUES ($1, $2)
ON CONFLICT DO NOTHING
`

type TestAddAudioFileTagParams struct {
	TagID       int32
	AudioFileID pgtype.UUID
}

// WITH res AS (
//
//	SELECT COALESCE(COUNT(*), 0) as total
//	FROM tags
//	WHERE tags.tag_name = $1
//
// )
// SELECT
//
//	CASE WHEN res.total > 0
//	    THEN (
//	        SELECT tags.id
//	        FROM tags
//	        WHERE tags.tag_name = $1
//	    )
//	    ELSE 0
//	END
//
// FROM res;
func (q *Queries) TestAddAudioFileTag(ctx context.Context, arg TestAddAudioFileTagParams) error {
	_, err := q.db.Exec(ctx, testAddAudioFileTag, arg.TagID, arg.AudioFileID)
	return err
}
