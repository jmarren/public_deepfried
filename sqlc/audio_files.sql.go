// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: audio_files.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/jmarren/deepfried/consts"
)

const addAudioFile = `-- name: AddAudioFile :one
INSERT INTO audio_files(
    user_id,
    title,
    audio_src,
    bpm,
    musical_key,
    musical_key_signature,
    major_minor,
    playback_seconds,
    file_size,
    usage_rights,
    artwork_src,
    vis_arr
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
RETURNING id
`

type AddAudioFileParams struct {
	UserID              pgtype.UUID
	Title               string
	AudioSrc            string
	Bpm                 int32
	MusicalKey          consts.MusicalKey
	MusicalKeySignature consts.MusicalKeySignature
	MajorMinor          consts.MajorMinor
	PlaybackSeconds     int32
	FileSize            int32
	UsageRights         pgtype.Text
	ArtworkSrc          string
	VisArr              []int32
}

func (q *Queries) AddAudioFile(ctx context.Context, arg AddAudioFileParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, addAudioFile,
		arg.UserID,
		arg.Title,
		arg.AudioSrc,
		arg.Bpm,
		arg.MusicalKey,
		arg.MusicalKeySignature,
		arg.MajorMinor,
		arg.PlaybackSeconds,
		arg.FileSize,
		arg.UsageRights,
		arg.ArtworkSrc,
		arg.VisArr,
	)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const addTestAudioFile = `-- name: AddTestAudioFile :one
WITH res AS (
    INSERT INTO audio_files (
        user_id,
        title,
        audio_src,
        bpm,
        musical_key,
        musical_key_signature,
        major_minor,
        usage_rights,
        playback_seconds,
        file_size,
        vis_arr,
        artwork_src
    )
    VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
    ON CONFLICT DO NOTHING
    RETURNING id --noqa
)
SELECT id FROM res
    UNION ALL
SELECT id FROM audio_files WHERE user_id = $1 AND title = $2
LIMIT 1
`

type AddTestAudioFileParams struct {
	UserID              pgtype.UUID
	Title               string
	AudioSrc            string
	Bpm                 int32
	MusicalKey          consts.MusicalKey
	MusicalKeySignature consts.MusicalKeySignature
	MajorMinor          consts.MajorMinor
	UsageRights         pgtype.Text
	PlaybackSeconds     int32
	FileSize            int32
	VisArr              []int32
	ArtworkSrc          string
}

func (q *Queries) AddTestAudioFile(ctx context.Context, arg AddTestAudioFileParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, addTestAudioFile,
		arg.UserID,
		arg.Title,
		arg.AudioSrc,
		arg.Bpm,
		arg.MusicalKey,
		arg.MusicalKeySignature,
		arg.MajorMinor,
		arg.UsageRights,
		arg.PlaybackSeconds,
		arg.FileSize,
		arg.VisArr,
		arg.ArtworkSrc,
	)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const doesTitleExistForUser = `-- name: DoesTitleExistForUser :one
SELECT COUNT(audio_files.title)
FROM audio_files
JOIN users
    ON users.id = audio_files.user_id
WHERE 
    audio_files.title = $1 
    AND users.id = $2
`

type DoesTitleExistForUserParams struct {
	Title string
	ID    pgtype.UUID
}

func (q *Queries) DoesTitleExistForUser(ctx context.Context, arg DoesTitleExistForUserParams) (int64, error) {
	row := q.db.QueryRow(ctx, doesTitleExistForUser, arg.Title, arg.ID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAudioFile = `-- name: GetAudioFile :one
SELECT 
    a.id,
    a.title,
    a.audio_src,
    a.bpm,
    a.playback_seconds,
    a.created,
    a.vis_arr,
    a.usage_rights,
    a.user_id,
    u.username,
    a.artwork_src,
    a.musical_key,
    a.major_minor,
    a.musical_key_signature
FROM audio_files AS a
INNER JOIN users AS u
    ON a.user_id = u.id
WHERE u.username = $1
    AND a.title = $2
LIMIT 1
`

type GetAudioFileParams struct {
	Username string
	Title    string
}

type GetAudioFileRow struct {
	ID                  pgtype.UUID
	Title               string
	AudioSrc            string
	Bpm                 int32
	PlaybackSeconds     int32
	Created             pgtype.Timestamp
	VisArr              []int32
	UsageRights         pgtype.Text
	UserID              pgtype.UUID
	Username            string
	ArtworkSrc          string
	MusicalKey          consts.MusicalKey
	MajorMinor          consts.MajorMinor
	MusicalKeySignature consts.MusicalKeySignature
}

func (q *Queries) GetAudioFile(ctx context.Context, arg GetAudioFileParams) (GetAudioFileRow, error) {
	row := q.db.QueryRow(ctx, getAudioFile, arg.Username, arg.Title)
	var i GetAudioFileRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.AudioSrc,
		&i.Bpm,
		&i.PlaybackSeconds,
		&i.Created,
		&i.VisArr,
		&i.UsageRights,
		&i.UserID,
		&i.Username,
		&i.ArtworkSrc,
		&i.MusicalKey,
		&i.MajorMinor,
		&i.MusicalKeySignature,
	)
	return i, err
}

const getAudioFileById = `-- name: GetAudioFileById :one
SELECT 
    playables.id, playables.user_id, playables.audio_src, playables.username, playables.title, playables.bpm, playables.playback_seconds, playables.created, playables.artwork_src
FROM playables
WHERE playables.id = $1
`

func (q *Queries) GetAudioFileById(ctx context.Context, audioFileID pgtype.UUID) (Playable, error) {
	row := q.db.QueryRow(ctx, getAudioFileById, audioFileID)
	var i Playable
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AudioSrc,
		&i.Username,
		&i.Title,
		&i.Bpm,
		&i.PlaybackSeconds,
		&i.Created,
		&i.ArtworkSrc,
	)
	return i, err
}

const getEditorsPicks = `-- name: GetEditorsPicks :many
SELECT
    playables.id, playables.user_id, playables.audio_src, playables.username, playables.title, playables.bpm, playables.playback_seconds, playables.created, playables.artwork_src
FROM playables
JOIN editors_picks 
    ON playables.id = editors_picks.audio_file_id
LIMIT 20
`

func (q *Queries) GetEditorsPicks(ctx context.Context) ([]Playable, error) {
	rows, err := q.db.Query(ctx, getEditorsPicks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Playable
	for rows.Next() {
		var i Playable
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AudioSrc,
			&i.Username,
			&i.Title,
			&i.Bpm,
			&i.PlaybackSeconds,
			&i.Created,
			&i.ArtworkSrc,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFourUserAudioFiles = `-- name: GetFourUserAudioFiles :many
SELECT
    id,
    title,
    audio_src,
    bpm,
    playback_seconds,
    created,
    vis_arr,
    artwork_src
FROM audio_files
WHERE user_id = $1
LIMIT 4
`

type GetFourUserAudioFilesRow struct {
	ID              pgtype.UUID
	Title           string
	AudioSrc        string
	Bpm             int32
	PlaybackSeconds int32
	Created         pgtype.Timestamp
	VisArr          []int32
	ArtworkSrc      string
}

func (q *Queries) GetFourUserAudioFiles(ctx context.Context, userID pgtype.UUID) ([]GetFourUserAudioFilesRow, error) {
	rows, err := q.db.Query(ctx, getFourUserAudioFiles, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFourUserAudioFilesRow
	for rows.Next() {
		var i GetFourUserAudioFilesRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.AudioSrc,
			&i.Bpm,
			&i.PlaybackSeconds,
			&i.Created,
			&i.VisArr,
			&i.ArtworkSrc,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJustAdded = `-- name: GetJustAdded :many
SELECT
    playables.id, playables.user_id, playables.audio_src, playables.username, playables.title, playables.bpm, playables.playback_seconds, playables.created, playables.artwork_src
FROM playables
ORDER BY playables.created DESC
LIMIT 4
`

func (q *Queries) GetJustAdded(ctx context.Context) ([]Playable, error) {
	rows, err := q.db.Query(ctx, getJustAdded)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Playable
	for rows.Next() {
		var i Playable
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AudioSrc,
			&i.Username,
			&i.Title,
			&i.Bpm,
			&i.PlaybackSeconds,
			&i.Created,
			&i.ArtworkSrc,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMostAudioFilesOrderedByListen = `-- name: GetMostAudioFilesOrderedByListen :many
SELECT
    a.id,
    a.title,
    a.audio_src,
    a.bpm,
    a.playback_seconds,
    a.created,
    a.vis_arr,
    a.user_id,
    u.username,
    a.artwork_src
FROM audio_files AS a
INNER JOIN users AS u
    ON a.user_id = u.id
ORDER BY a.listen_count DESC
LIMIT 20
`

type GetMostAudioFilesOrderedByListenRow struct {
	ID              pgtype.UUID
	Title           string
	AudioSrc        string
	Bpm             int32
	PlaybackSeconds int32
	Created         pgtype.Timestamp
	VisArr          []int32
	UserID          pgtype.UUID
	Username        string
	ArtworkSrc      string
}

func (q *Queries) GetMostAudioFilesOrderedByListen(ctx context.Context) ([]GetMostAudioFilesOrderedByListenRow, error) {
	rows, err := q.db.Query(ctx, getMostAudioFilesOrderedByListen)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMostAudioFilesOrderedByListenRow
	for rows.Next() {
		var i GetMostAudioFilesOrderedByListenRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.AudioSrc,
			&i.Bpm,
			&i.PlaybackSeconds,
			&i.Created,
			&i.VisArr,
			&i.UserID,
			&i.Username,
			&i.ArtworkSrc,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMostPopularAudioFiles = `-- name: GetMostPopularAudioFiles :many
SELECT
    playables.id, playables.user_id, playables.audio_src, playables.username, playables.title, playables.bpm, playables.playback_seconds, playables.created, playables.artwork_src
FROM playables
JOIN audio_files 
    ON audio_files.id = playables.id
ORDER BY audio_files.listen_count DESC
LIMIT 20
`

func (q *Queries) GetMostPopularAudioFiles(ctx context.Context) ([]Playable, error) {
	rows, err := q.db.Query(ctx, getMostPopularAudioFiles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Playable
	for rows.Next() {
		var i Playable
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AudioSrc,
			&i.Username,
			&i.Title,
			&i.Bpm,
			&i.PlaybackSeconds,
			&i.Created,
			&i.ArtworkSrc,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayableByTitleAndUsername = `-- name: GetPlayableByTitleAndUsername :one
SELECT 
    playables.id, playables.user_id, playables.audio_src, playables.username, playables.title, playables.bpm, playables.playback_seconds, playables.created, playables.artwork_src,
    audio_files.vis_arr
FROM 
    playables
JOIN audio_files
    ON playables.id = audio_files.id
WHERE 
    playables.username = $1
    AND playables.title = $2
`

type GetPlayableByTitleAndUsernameParams struct {
	Username string
	Title    string
}

type GetPlayableByTitleAndUsernameRow struct {
	Playable Playable
	VisArr   []int32
}

func (q *Queries) GetPlayableByTitleAndUsername(ctx context.Context, arg GetPlayableByTitleAndUsernameParams) (GetPlayableByTitleAndUsernameRow, error) {
	row := q.db.QueryRow(ctx, getPlayableByTitleAndUsername, arg.Username, arg.Title)
	var i GetPlayableByTitleAndUsernameRow
	err := row.Scan(
		&i.Playable.ID,
		&i.Playable.UserID,
		&i.Playable.AudioSrc,
		&i.Playable.Username,
		&i.Playable.Title,
		&i.Playable.Bpm,
		&i.Playable.PlaybackSeconds,
		&i.Playable.Created,
		&i.Playable.ArtworkSrc,
		&i.VisArr,
	)
	return i, err
}

const getUserAudioFiles = `-- name: GetUserAudioFiles :many
SELECT
    playables.id, playables.user_id, playables.audio_src, playables.username, playables.title, playables.bpm, playables.playback_seconds, playables.created, playables.artwork_src
FROM playables
JOIN audio_files 
    ON audio_files.id = playables.id
WHERE playables.user_id = $1
ORDER BY audio_files.listen_count DESC
LIMIT 20
`

func (q *Queries) GetUserAudioFiles(ctx context.Context, userID pgtype.UUID) ([]Playable, error) {
	rows, err := q.db.Query(ctx, getUserAudioFiles, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Playable
	for rows.Next() {
		var i Playable
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AudioSrc,
			&i.Username,
			&i.Title,
			&i.Bpm,
			&i.PlaybackSeconds,
			&i.Created,
			&i.ArtworkSrc,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserAudioFilesWithLimit = `-- name: GetUserAudioFilesWithLimit :many
SELECT
    playables.id, playables.user_id, playables.audio_src, playables.username, playables.title, playables.bpm, playables.playback_seconds, playables.created, playables.artwork_src,
    audio_file_tag_arrays.tag_array
FROM playables
FULL JOIN audio_file_tag_arrays
        ON playables.id = audio_file_tag_arrays.id
JOIN audio_files
    ON playables.id = audio_files.id 
WHERE playables.user_id = $1
ORDER BY audio_files.listen_count DESC
LIMIT $2
`

type GetUserAudioFilesWithLimitParams struct {
	UserID          pgtype.UUID
	NumberOfResults int32
}

type GetUserAudioFilesWithLimitRow struct {
	Playable Playable
	TagArray []string
}

func (q *Queries) GetUserAudioFilesWithLimit(ctx context.Context, arg GetUserAudioFilesWithLimitParams) ([]GetUserAudioFilesWithLimitRow, error) {
	rows, err := q.db.Query(ctx, getUserAudioFilesWithLimit, arg.UserID, arg.NumberOfResults)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserAudioFilesWithLimitRow
	for rows.Next() {
		var i GetUserAudioFilesWithLimitRow
		if err := rows.Scan(
			&i.Playable.ID,
			&i.Playable.UserID,
			&i.Playable.AudioSrc,
			&i.Playable.Username,
			&i.Playable.Title,
			&i.Playable.Bpm,
			&i.Playable.PlaybackSeconds,
			&i.Playable.Created,
			&i.Playable.ArtworkSrc,
			&i.TagArray,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserAudioFilesAndWhetherPinned = `-- name: ListUserAudioFilesAndWhetherPinned :many
WITH uaf AS (
    SELECT 
        audio_files.id as fid,
        audio_files.title as ft
    FROM audio_files
    WHERE audio_files.user_id = $1
)
SELECT 
    uaf.ft AS title, 
    CASE 
    WHEN (
        SELECT COUNT(*) 
        FROM pins 
        WHERE pins.file_id = uaf.fid
    ) > 0 THEN TRUE
    ELSE FALSE
    END AS pinned
FROM uaf
`

type ListUserAudioFilesAndWhetherPinnedRow struct {
	Title  string
	Pinned bool
}

func (q *Queries) ListUserAudioFilesAndWhetherPinned(ctx context.Context, userID pgtype.UUID) ([]ListUserAudioFilesAndWhetherPinnedRow, error) {
	rows, err := q.db.Query(ctx, listUserAudioFilesAndWhetherPinned, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUserAudioFilesAndWhetherPinnedRow
	for rows.Next() {
		var i ListUserAudioFilesAndWhetherPinnedRow
		if err := rows.Scan(&i.Title, &i.Pinned); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
