// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: users.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createProfile = `-- name: CreateProfile :exec
INSERT INTO profiles (user_id, bio)
VALUES ($1::uuid, $2)
`

type CreateProfileParams struct {
	UserID pgtype.UUID
	Bio    pgtype.Text
}

func (q *Queries) CreateProfile(ctx context.Context, arg CreateProfileParams) error {
	_, err := q.db.Exec(ctx, createProfile, arg.UserID, arg.Bio)
	return err
}

const createProfileTest = `-- name: CreateProfileTest :exec
INSERT INTO profiles (user_id, bio)
VALUES ($1, $2)
ON CONFLICT DO NOTHING
`

type CreateProfileTestParams struct {
	UserID pgtype.UUID
	Bio    pgtype.Text
}

func (q *Queries) CreateProfileTest(ctx context.Context, arg CreateProfileTestParams) error {
	_, err := q.db.Exec(ctx, createProfileTest, arg.UserID, arg.Bio)
	return err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (cognito_id, username)
VALUES ($1, $2)
RETURNING id as inserted_id
`

type CreateUserParams struct {
	CognitoID string
	Username  string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createUser, arg.CognitoID, arg.Username)
	var inserted_id pgtype.UUID
	err := row.Scan(&inserted_id)
	return inserted_id, err
}

const createUserTest = `-- name: CreateUserTest :one
INSERT INTO users (cognito_id, username)
VALUES ($1, $2)
ON CONFLICT DO NOTHING
RETURNING id as inserted_id
`

type CreateUserTestParams struct {
	CognitoID string
	Username  string
}

func (q *Queries) CreateUserTest(ctx context.Context, arg CreateUserTestParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createUserTest, arg.CognitoID, arg.Username)
	var inserted_id pgtype.UUID
	err := row.Scan(&inserted_id)
	return inserted_id, err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users
WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const doesUsernameExist = `-- name: DoesUsernameExist :one
SELECT COUNT(*)
FROM users
WHERE username = $1
`

func (q *Queries) DoesUsernameExist(ctx context.Context, username string) (int64, error) {
	row := q.db.QueryRow(ctx, doesUsernameExist, username)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAmIFollowing = `-- name: GetAmIFollowing :one
SELECT CASE WHEN COALESCE(COUNT(*), 0) > 0 THEN TRUE
        ELSE FALSE
    END 
FROM following
WHERE following.follower_id = $1
    AND following.following_id = $2
`

type GetAmIFollowingParams struct {
	MyID    pgtype.UUID
	TheirID pgtype.UUID
}

func (q *Queries) GetAmIFollowing(ctx context.Context, arg GetAmIFollowingParams) (bool, error) {
	row := q.db.QueryRow(ctx, getAmIFollowing, arg.MyID, arg.TheirID)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const getFiveNewestUsers = `-- name: GetFiveNewestUsers :many
SELECT id, cognito_id, username, user_id, created, user_location, last_modified, bio 
FROM users
JOIN profiles
    ON users.id = profiles.user_id
ORDER BY profiles.created DESC
LIMIT 5
`

type GetFiveNewestUsersRow struct {
	ID           pgtype.UUID
	CognitoID    string
	Username     string
	UserID       pgtype.UUID
	Created      pgtype.Timestamp
	UserLocation pgtype.Text
	LastModified pgtype.Timestamp
	Bio          pgtype.Text
}

func (q *Queries) GetFiveNewestUsers(ctx context.Context) ([]GetFiveNewestUsersRow, error) {
	rows, err := q.db.Query(ctx, getFiveNewestUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFiveNewestUsersRow
	for rows.Next() {
		var i GetFiveNewestUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.CognitoID,
			&i.Username,
			&i.UserID,
			&i.Created,
			&i.UserLocation,
			&i.LastModified,
			&i.Bio,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNumberFollowers = `-- name: GetNumberFollowers :one
SELECT count
FROM follower_counts
WHERE following_id = $1
`

func (q *Queries) GetNumberFollowers(ctx context.Context, followingID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getNumberFollowers, followingID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getNumberFollowing = `-- name: GetNumberFollowing :one
SELECT count
FROM following_counts
WHERE follower_id = $1
`

func (q *Queries) GetNumberFollowing(ctx context.Context, followerID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getNumberFollowing, followerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getUser = `-- name: GetUser :one
SELECT
    id,
    cognito_id,
    username
FROM users
WHERE id = $1
`

func (q *Queries) GetUser(ctx context.Context, id pgtype.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUser, id)
	var i User
	err := row.Scan(&i.ID, &i.CognitoID, &i.Username)
	return i, err
}

const getUserBio = `-- name: GetUserBio :one
SELECT bio
FROM profiles
WHERE user_id = $1
`

func (q *Queries) GetUserBio(ctx context.Context, userID pgtype.UUID) (pgtype.Text, error) {
	row := q.db.QueryRow(ctx, getUserBio, userID)
	var bio pgtype.Text
	err := row.Scan(&bio)
	return bio, err
}

const getUserInfo = `-- name: GetUserInfo :one
WITH uid AS (
        SELECT id AS i
        FROM users
        WHERE username = $1
)
SELECT 
    (
        SELECT bio FROM profiles WHERE user_id = uid.i
    ),
    (
    SELECT 
    COUNT(*) AS followers
    FROM following
    WHERE following_id = uid.i
    ),
    (
    SELECT 
    COUNT(*) AS following
    FROM following
    WHERE follower_id = uid.i
    )
FROM users
JOIN uid 
    ON uid.i = users.id
WHERE users.username = $1
`

type GetUserInfoRow struct {
	Bio       pgtype.Text
	Followers int64
	Following int64
}

func (q *Queries) GetUserInfo(ctx context.Context, username string) (GetUserInfoRow, error) {
	row := q.db.QueryRow(ctx, getUserInfo, username)
	var i GetUserInfoRow
	err := row.Scan(&i.Bio, &i.Followers, &i.Following)
	return i, err
}

const getUserWithCognitoId = `-- name: GetUserWithCognitoId :one
SELECT
    id, cognito_id, username
FROM
    users
WHERE
    cognito_id = $1
LIMIT 1
`

func (q *Queries) GetUserWithCognitoId(ctx context.Context, cognitoID string) (User, error) {
	row := q.db.QueryRow(ctx, getUserWithCognitoId, cognitoID)
	var i User
	err := row.Scan(&i.ID, &i.CognitoID, &i.Username)
	return i, err
}

const getUserWithUsername = `-- name: GetUserWithUsername :one
SELECT
    id, cognito_id, username
FROM 
    users
WHERE
    username = $1
LIMIT 1
`

func (q *Queries) GetUserWithUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRow(ctx, getUserWithUsername, username)
	var i User
	err := row.Scan(&i.ID, &i.CognitoID, &i.Username)
	return i, err
}

const isCognitoIdPresent = `-- name: IsCognitoIdPresent :one
SELECT
    CASE
        WHEN
            EXISTS (
                SELECT 1
                FROM users
                WHERE cognito_id = $1
            )
            THEN 1
        ELSE 0
    END
`

func (q *Queries) IsCognitoIdPresent(ctx context.Context, cognitoID string) (int32, error) {
	row := q.db.QueryRow(ctx, isCognitoIdPresent, cognitoID)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const isUserAdmin = `-- name: IsUserAdmin :one
SELECT CASE WHEN COALESCE(COUNT(*), 0) > 0 THEN TRUE
            ELSE FALSE
        END
FROM admins 
WHERE admins.user_id = $1
`

func (q *Queries) IsUserAdmin(ctx context.Context, userID pgtype.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, isUserAdmin, userID)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const updateUserBio = `-- name: UpdateUserBio :exec
UPDATE profiles
SET bio = $2
WHERE user_id = $1
`

type UpdateUserBioParams struct {
	UserID pgtype.UUID
	Bio    pgtype.Text
}

func (q *Queries) UpdateUserBio(ctx context.Context, arg UpdateUserBioParams) error {
	_, err := q.db.Exec(ctx, updateUserBio, arg.UserID, arg.Bio)
	return err
}

const updateUserUsername = `-- name: UpdateUserUsername :exec
UPDATE users
SET username = $2
WHERE id = $1
`

type UpdateUserUsernameParams struct {
	ID       pgtype.UUID
	Username string
}

func (q *Queries) UpdateUserUsername(ctx context.Context, arg UpdateUserUsernameParams) error {
	_, err := q.db.Exec(ctx, updateUserUsername, arg.ID, arg.Username)
	return err
}
