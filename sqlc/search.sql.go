// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: search.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/jmarren/deepfried/consts"
)

const searchAudioFiles = `-- name: SearchAudioFiles :many
WITH sc AS (
	SELECT 
		COUNT(*) AS stem_count,
		audio_file_id
	FROM audio_file_stems
	FULL JOIN audio_files
		ON audio_file_stems.audio_file_id = audio_files.id
	GROUP BY audio_file_stems.audio_file_id
)
SELECT	
	playables.id, playables.user_id, playables.audio_src, playables.username, playables.title, playables.bpm, playables.playback_seconds, playables.created, playables.artwork_src,
	sc.stem_count,
	audio_files.vis_arr,
	audio_files.musical_key,
	audio_files.musical_key_signature,
        audio_files.major_minor,
	stem_arrays.stem_file_names,
	ta.tag_array
FROM audio_files
JOIN users 
	ON audio_files.user_id = users.id
FULL JOIN audio_file_tag_arrays ta
	ON audio_files.id = ta.id
FULL JOIN sc
	ON audio_files.id = sc.audio_file_id
FULL JOIN stem_arrays
	ON audio_files.id = stem_arrays.af_id
JOIN playables
	ON audio_files.id = playables.id
JOIN search_doc
    ON search_doc.audio_file_id = audio_files.id
WHERE 
(
	($1::text = '') OR 
($1::text= 'use-exact' AND $2::integer = -1 OR audio_files.bpm = $2::integer) 
	OR ($1::text = 'use-range' AND ($3::integer = -1 OR audio_files.bpm > $3::integer)
		   AND ($4::integer = -1 OR audio_files.bpm < $4::integer))
)
AND (
cast_to_musical_key($5::text) IS NULL OR audio_files.musical_key = cast_to_musical_key($5::text)
)
AND (
  cast_to_musical_key_signature($6::text) IS NULL OR audio_files.musical_key_signature = cast_to_musical_key_signature($6::text)
)
AND (
  cast_to_major_minor($7::text) IS NULL OR audio_files.major_minor = cast_to_major_minor($7::text)
)
AND (
  $8::bool != 'on' OR sc.stem_count > 0
)
ORDER BY similarity(search_doc.doc, $9::text) DESC
LIMIT 20
OFFSET $10::integer
`

type SearchAudioFilesParams struct {
	BpmRadio   string
	ExactBpm   int32
	MinBpm     int32
	MaxBpm     int32
	MusicalKey string
	KeySig     string
	MajorMinor string
	StemsOnly  bool
	Keyword    string
	PageOffset int32
}

type SearchAudioFilesRow struct {
	Playable            Playable
	StemCount           pgtype.Int8
	VisArr              []int32
	MusicalKey          consts.MusicalKey
	MusicalKeySignature consts.MusicalKeySignature
	MajorMinor          consts.MajorMinor
	StemFileNames       []string
	TagArray            []string
}

func (q *Queries) SearchAudioFiles(ctx context.Context, arg SearchAudioFilesParams) ([]SearchAudioFilesRow, error) {
	rows, err := q.db.Query(ctx, searchAudioFiles,
		arg.BpmRadio,
		arg.ExactBpm,
		arg.MinBpm,
		arg.MaxBpm,
		arg.MusicalKey,
		arg.KeySig,
		arg.MajorMinor,
		arg.StemsOnly,
		arg.Keyword,
		arg.PageOffset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchAudioFilesRow
	for rows.Next() {
		var i SearchAudioFilesRow
		if err := rows.Scan(
			&i.Playable.ID,
			&i.Playable.UserID,
			&i.Playable.AudioSrc,
			&i.Playable.Username,
			&i.Playable.Title,
			&i.Playable.Bpm,
			&i.Playable.PlaybackSeconds,
			&i.Playable.Created,
			&i.Playable.ArtworkSrc,
			&i.StemCount,
			&i.VisArr,
			&i.MusicalKey,
			&i.MusicalKeySignature,
			&i.MajorMinor,
			&i.StemFileNames,
			&i.TagArray,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchForUsers = `-- name: SearchForUsers :many
SELECT 
   username, bio, id
FROM user_search_rows
ORDER BY (similarity(user_search_rows.username, $1) ^ 2) + (similarity((COALESCE(user_search_rows.bio, '')), $1)) DESC
LIMIT 4
`

func (q *Queries) SearchForUsers(ctx context.Context, similarity string) ([]UserSearchRow, error) {
	rows, err := q.db.Query(ctx, searchForUsers, similarity)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserSearchRow
	for rows.Next() {
		var i UserSearchRow
		if err := rows.Scan(&i.Username, &i.Bio, &i.ID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchKeywordForDropdown = `-- name: SearchKeywordForDropdown :many
WITH ta AS (
	SELECT  audio_files.id AS af_id, array_agg(t.tag_name) AS tag_array
	FROM audio_file_tags at
	JOIN tags t
		ON t.id = at.tag_id
	JOIN audio_files
		ON audio_files.id = at.audio_file_id
	GROUP BY audio_files.id
)
SELECT 
	audio_files.title,
	users.username,
	audio_files.user_id,
	audio_files.artwork_src
FROM audio_files
JOIN users 
	ON audio_files.user_id = users.id
FULL JOIN ta
	ON audio_files.id = ta.af_id
JOIN search_doc
    ON search_doc.audio_file_id = audio_files.id
ORDER BY similarity(search_doc.doc, $1) DESC
LIMIT 5
`

type SearchKeywordForDropdownRow struct {
	Title      string
	Username   string
	UserID     pgtype.UUID
	ArtworkSrc string
}

func (q *Queries) SearchKeywordForDropdown(ctx context.Context, similarity string) ([]SearchKeywordForDropdownRow, error) {
	rows, err := q.db.Query(ctx, searchKeywordForDropdown, similarity)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchKeywordForDropdownRow
	for rows.Next() {
		var i SearchKeywordForDropdownRow
		if err := rows.Scan(
			&i.Title,
			&i.Username,
			&i.UserID,
			&i.ArtworkSrc,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchKeywordWithFilters = `-- name: SearchKeywordWithFilters :many
SELECT title, username, stem_count, audio_src, user_id, artwork_src, bpm, vis_arr, playback_seconds, created, musical_key, musical_key_signature, major_minor, stem_file_names, tag_array, doc
FROM audio_file_search_rows
WHERE 
(
	($3 = -1) OR 
	($3 = 1 AND $4 = -1 OR audio_files.bpm = $4) 
	OR ($3 = 2 AND ($5 = -1 OR audio_files.bpm > $5)
		   AND ($6 = -1 OR audio_files.bpm < $6))
)
AND (
  cast_to_musical_key($7) IS NULL OR audio_files.musical_key = cast_to_musical_key($7)
)
AND (
  cast_to_musical_key_signature($8) IS NULL OR audio_files.musical_key_signature = cast_to_musical_key_signature($8)
)
AND (
  cast_to_major_minor($9) IS NULL OR audio_files.major_minor = cast_to_major_minor($9)
)
AND (
  $10 != 'on' OR sc.stem_count > 0
)
ORDER BY similarity(search_doc.doc, $1) DESC
LIMIT 20
OFFSET $2
`

type SearchKeywordWithFiltersParams struct {
	Similarity string
	Offset     int32
	Column3    interface{}
	Column4    interface{}
	Column5    interface{}
	Column6    interface{}
	TInput     string
	TInput_2   string
	TInput_3   string
	Column10   interface{}
}

func (q *Queries) SearchKeywordWithFilters(ctx context.Context, arg SearchKeywordWithFiltersParams) ([]AudioFileSearchRow, error) {
	rows, err := q.db.Query(ctx, searchKeywordWithFilters,
		arg.Similarity,
		arg.Offset,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.TInput,
		arg.TInput_2,
		arg.TInput_3,
		arg.Column10,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AudioFileSearchRow
	for rows.Next() {
		var i AudioFileSearchRow
		if err := rows.Scan(
			&i.Title,
			&i.Username,
			&i.StemCount,
			&i.AudioSrc,
			&i.UserID,
			&i.ArtworkSrc,
			&i.Bpm,
			&i.VisArr,
			&i.PlaybackSeconds,
			&i.Created,
			&i.MusicalKey,
			&i.MusicalKeySignature,
			&i.MajorMinor,
			&i.StemFileNames,
			&i.TagArray,
			&i.Doc,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const testingTagArrQuery = `-- name: TestingTagArrQuery :many
SELECT  audio_files.id AS af_id, array_agg(t.tag_name) AS tag_array
FROM audio_file_tags at
JOIN tags t
	ON t.id = at.tag_id
JOIN audio_files
ON audio_files.id = at.audio_file_id
GROUP BY audio_files.id
`

type TestingTagArrQueryRow struct {
	AfID     pgtype.UUID
	TagArray interface{}
}

func (q *Queries) TestingTagArrQuery(ctx context.Context) ([]TestingTagArrQueryRow, error) {
	rows, err := q.db.Query(ctx, testingTagArrQuery)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TestingTagArrQueryRow
	for rows.Next() {
		var i TestingTagArrQueryRow
		if err := rows.Scan(&i.AfID, &i.TagArray); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
